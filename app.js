import * as THREE from "https://cdn.skypack.dev/three@0.128.0";
import { OrbitControls } from "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js";

const piecesMap = new Map([
  ["UBL", 0], ["UBR", 1], ["UFL", 2], ["LBU", 3], ["LFU", 4], ["LDF", 5], ["LDB", 6],
  ["FUL", 7], ["FDR", 8], ["FDL", 9], ["RUB", 10], ["RDB", 11], ["RDF", 12], ["BUR", 13],
  ["BUL", 14], ["BDL", 15], ["BDR", 16], ["DFL", 17], ["DFR", 18], ["DBR", 19], ["DBL", 20]
]);

const container = document.getElementById('three-container');
const scene = createScene();
const camera = createCamera();
const renderer = new THREE.WebGLRenderer();

const orbit = new OrbitControls(camera, renderer.domElement); 

// Set the renderer size and append the DOM element
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

orbit.enableDamping = true;  // Optional: Enable damping for smoother movement
orbit.dampingFactor = 0.25;
orbit.screenSpacePanning = false;
//orbit.enableZoom = false;
orbit.maxDistance = 10;
orbit.minDistance = 5;
let cubelets = [];
let all_moves = [];


document.addEventListener('DOMContentLoaded', () => {
    initialize();
    setupFormListener();
    // handleRotations();
});

function initialize() {
    // generated by chatgpt 
    for (let i = scene.children.length - 1; i >= 0; i--) {
        const child = scene.children[i];
        if (child.type === 'Group') {
            scene.remove(child);
        }
    }
    cubelets = [];

    var ambientLight = new THREE.AmbientLight(0xffffff, 2);
    scene.add( ambientLight );

    var light = new THREE.DirectionalLight( 'white', 1 );
    light.position.set( 1, 1, 1 );
    scene.add( light );

    createCube(scene);
    camera.position.set(5, 2, 4);
    // orbit.target.set(0, -1, 0); // shift rotation target down
    // orbit.update();
    camera.lookAt(2, 1, 1); 
    scene.rotation.y = -Math.PI / 4 - Math.PI / 8;
    animate(cubelets, scene, camera, renderer, orbit);
}

// Function to handle canvas dimensions for high-DPI scaling
function setCanvasDimensions(canvas, width, height, set2dTransform = false) {
    const ratio = window.devicePixelRatio;  // Get device pixel ratio
    canvas.width = width * ratio;  // Scale the width
    canvas.height = height * ratio; // Scale the height
    canvas.style.width = `${width}px`;  // Set the style width
    canvas.style.height = `${height}px`;  // Set the style height

    if (set2dTransform) {
        canvas.getContext('2d').setTransform(ratio, 0, 0, ratio, 0, 0);
    }
}

// Adjust for resizing the window
window.addEventListener('resize', () => {
    const width = window.innerWidth;
    const height = window.innerHeight;

    camera.aspect = width / height;  // Update aspect ratio
    camera.updateProjectionMatrix();  // Update projection matrix
    renderer.setSize(width, height);  // Update the renderer size
    setCanvasDimensions(renderer.domElement, width, height);  // Handle high-DPI scaling
});

// Function to create the scene
function createScene() {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('black');
    return scene;
}

// Function to create the camera
function createCamera() {
    const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
    return camera;
}

function createCube(scene) {
    const cubeGroup = new THREE.Group(); // Create the group outside the loop

    // Colors for each face (you can customize this)
    const faceColors = [
        new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // Green
        new THREE.MeshBasicMaterial({ color: 0x0000FF }), // Blue
        new THREE.MeshBasicMaterial({ color: 0xFFFFFF }), // White
        new THREE.MeshBasicMaterial({ color: 0xFFFF00 }), // Yellow
        new THREE.MeshBasicMaterial({ color: 0xFFA500 }), // Orange
        new THREE.MeshBasicMaterial({ color: 0xFF0000 })  // Red
    ];

    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const spacing = 1.015;
    // Create the small cubes
    for (let z = -1; z <= 1; z++) {
        for (let y = -1; y <= 1; y++) {
            for (let x = -1; x <= 1; x++) {
                const materials = [
                    faceColors[0], // Front face (Green)
                    faceColors[1], // Back face (Blue)
                    faceColors[2], // Top face (White)
                    faceColors[3], // Bottom face (Yellow)
                    faceColors[4], // Left face (Orange)
                    faceColors[5]  // Right face (Red)
                ];

                const cube = new THREE.Mesh(geometry, materials);
                
                const edges = new THREE.EdgesGeometry(cube.geometry);
                const wireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                cube.add(wireframe);

                // Create a group for each cube and add the cube and edge lines to it
                const cubeWithLineGroup = new THREE.Group();
                cubeWithLineGroup.add(cube);
                cubeWithLineGroup.position.set(x * spacing, y * spacing, z * spacing); // Position the cube in the grid
                cubelets.push(cubeWithLineGroup);
                cubeGroup.add(cubeWithLineGroup);          
            }
        }
    }
    scene.add(cubeGroup);
    cubeGroup.position.y = -3;
    return cubeGroup;
}

function rotateSide(axis, layer, direction) {
    const rotationAxis = new THREE.Vector3();
    rotationAxis[axis] = 1;
    const rotationMatrix = new THREE.Matrix4().makeRotationAxis(rotationAxis, direction * Math.PI / 2);
    cubelets.forEach(cubelet => {
        if (Math.round(cubelet.position[axis]) === layer) {
            cubelet.applyMatrix4(rotationMatrix);
            cubelet.position.round();
        }
    });
}

function handleRotations(rotations) {
    const axes = ['x', 'y', 'z'];
    const layers = [-1, 0, 1];
    const directions = [-1, 1];

    rotations.forEach(r => {
            const axis = axes[r[0]];
            const layer = layers[r[1]];
            const direction = directions[r[2]];
            rotateSide(axis, layer, direction);
        })
    }

function rotateCube(moves) {
    const moveList = moves.trim().split(" ");
    all_moves = moveList
    const rotations = []
    moveList.forEach(move => {
        console.log(move)
        if (move === "F") {
            rotations.push([0, 2, 0])
        }
        if (move === "F'") {
            rotations.push([0, 2, 1])
        }
        if (move === "U'") {
            rotations.push([1, 2, 1])
        }
        if (move === "U") {
            rotations.push([1, 2, 0])
        }
        if (move === "U2") {
            rotations.push([1, 2, 0])
            rotations.push([1, 2, 0])
        }
        if (move === "D'") {
            rotations.push([1, 0, 0])
        }
        if (move === "D") {
            rotations.push([1, 0, 1])
        }
        if (move === "D2") {
            rotations.push([1, 0, 1])
            rotations.push([1, 0, 1])
        }
        if (move === "L") {
            rotations.push([2, 2, 0])
        }
        if (move === "L'") {
            rotations.push([2, 2, 1])
        }
        if (move === "R'") {
            rotations.push([2, 0, 0])
        }
        if (move === "R") {
            rotations.push([2, 0, 1])
        }
        if (move === "R2") {
            rotations.push([2, 0, 1])
            rotations.push([2, 0, 1])
        }
    });
    console.log(rotations)
    handleRotations(rotations)
    handleRotations(rotations)
}


// Function to animate the cube
function animate(cube, scene, camera, renderer, orbit) {
    function animateLoop() {
        requestAnimationFrame(animateLoop);  
        //TWEEN.update();
        orbit.update();  // keep controls smooth + prevent snapping
        renderer.render(scene, camera);  
    }
    animateLoop();
}

function handleMove(move) {
    if (move === "F") {
        rotateSide('x', 1, -1)
    }
    if (move === "F'") {
        rotateSide('x', 1, 1);
    }
    if (move === "U'") {
        rotateSide('y', 1, 1);
    }
    if (move === "U") {
        rotateSide('y', 1, -1);
    }
    if (move === "U2") {
        rotateSide('y', 1, -1);
        rotateSide('y', 1, -1);
    }
    if (move === "D'") {
        rotateSide('y', -1, -1);
    }
    if (move === "D") {
        rotateSide('y', -1, 1);
    }
    if (move === "D2") {
        rotateSide('y', -1, 1);
        rotateSide('y', -1, 1);
    }
    if (move === "L") {
        rotateSide('z', 1, -1);
    }
    if (move === "L'") {
        rotateSide('z', 1, 1);
    }
    if (move === "R'") {
        rotateSide('z', -1, -1);
    }
    if (move === "R") {
        rotateSide('z', -1, 1);
    }
    if (move === "R2") {
        rotateSide('z', -1, 1);
        rotateSide('z', -1, 1);
    }
    if (move === "Lw") {
        rotateSide('z', 1, -1);
        rotateSide('z', 0, -1);
    }
    if (move === "Lw'") {
        rotateSide('z', 1, 1);
        rotateSide('z', 0, 1);
    }
    if (move === "M") {
        rotateSide('z', 0, 1);
    }
}

function getInverseMove(move) {
    if (move.endsWith("2")) {
        return move; // 180-degree turns are their own inverse
    } else if (move.endsWith("'")) {
        return move.slice(0, -1); // Remove the apostrophe
    } else {
        return move + "'"; // Add the apostrophe
    }
}

let current_move
document.addEventListener('keydown', (event) => {
    //console.log(all_moves)
    switch (event.key) {
        case 'ArrowRight':
            handleMove(all_moves[current_move])
            current_move = Math.min(all_moves.length, current_move + 1)
            break
        case 'ArrowLeft':  
            let c = current_move
            current_move = Math.max(0, current_move - 1)
            if (c > 0) {
                handleMove(getInverseMove(all_moves[current_move]))
            }
            break
    }
    //console.log(current_move)
})


// Function to set up the form listener
function setupFormListener() {
    document.getElementById('pieces').addEventListener('submit', async (event) => {
        event.preventDefault();
        const first = document.getElementById('firstPiece').value;
        const second = document.getElementById('secondPiece').value;

        document.getElementById('firstPieceName').innerHTML = first;
        document.getElementById('secondPieceName').innerHTML = second;

        const url = `https://3styleapi.vercel.app/get_algorithm?firstPiece=${piecesMap.get(first)}&secondPiece=${piecesMap.get(second)}`;

        try {
            const response = await fetch(url, { method: 'GET' });

            if (!response.ok) {
                throw new Error('Failed to fetch the algorithm');
            }

            const data = await response.json();

            if (data.comm == '' && data.moves == '') {
                alert("Cannot cycle to same piece!");
                document.getElementById('commResult').innerText = `No comm exists`;
                document.getElementById('movesResult').innerText = `No moves exist`;
            } else {
                document.getElementById('commResult').innerText = `${data.comm}`;
                document.getElementById('movesResult').innerText = `${data.moves}`;
                initialize();
                rotateCube(data.moves);
                current_move = 0
            }
        } catch (error) {
            console.error('Error:', error);
            document.getElementById('commResult').innerText = 'Error fetching algorithm.';
            document.getElementById('movesResult').innerText = 'Error fetching algorithm.';
        }
    });
}
